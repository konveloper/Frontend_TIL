## 브라우저의 렌더링 원리
💡 **CRP :** 브라우저는 사용자가 선택한 자원을 서버에 요청하고 브라우저에 표시하여 보여주는 과정  <br>
**1. DOM, CSSOM 파싱 2. 스타일 계산 3. 레이아웃 4. 페인트 5. 컴포지팅**
```
1. 파싱 : HTML  파싱 ⇒ DOM 트리 구축, CSS 파싱 ⇒ 트리 구축,  Javascript 실행
2. 스타일: DOM과 CSSOM을 조합하여 렌더트리를 구축 
3. 레이아웃 : 뷰포트 기반으로 렌더트리의 각 노드가 가지는 정확한 위치와 크기를 계산
4. 페인트 : 계산된 값을 이용해 각 노드를 화면상의 실제 픽셀로 변환, 레이어를 만든다.
5. 컴포지팅 : 레이어를 합성하여 실제 화면에 나타낸다. 화면에서 웹 페이지를 볼 수 있다.
```
브라우저는 유저가 선택한 자원을 서버로부터 받아와서 유저에게 보여준다. 자원은 페이지 외에도 이미지, 비디오 등의 컨텐츠들도 포함한다. 받아온 자원들은 렌더링 과정을 통해 유저에게 보여주게 된다. 
1. 브라우저가 페이지를 렌더링하려면 가장 먼저 받아온 HTML 파일을 해석해야한다.
  - **Parsing** : 하나의 프로그램을 런타임 환경(예를 들면, 브라우저 내 자바스크립트 엔진)이 실제로 실행할 수 있는 내부 포맷으로 분석하고 변환하는 것을 의미합니다. 즉, 파싱은 문서의 내용을 토큰(token)으로 분석하고, 문법적 의미와 구조를 반영한 파스 트리(parse tree)를 생성하는 과정입니다.
파싱 단계는 HTML 파일을 해석하여 DOM(Document Object Model) Tree를 구성하는 단계이다. 브라우저가 문서를 분해해서 해석하는 과정
  - **DOM?** **(Document Object Model)** 문서 객체 모델. 웹 페이지를 이루는 태그들을 자바스크립트가 이용할 수 있도록 브라우저가 트리구조로 만든 객체 모델. 문서 객체란 html, head, body와 같은 태그들을 자바스크립트가 이용할 수 있는 (메모리에 보관할 수 있는) 객체를 의미. DOM은 HTML과 스크립팅 언어(JavaScript)를 서로 이어주는 역할.
파싱 중 HTML에 CSS가 포함되어 있다면 CSSOM(CSS Object Model) Tree 구성 작업을 진행한다.
  - **CSSOM? (CSS Object Model)** CSS 내용을 파싱하여 자료를 구조화 한 것. DOM처럼 CSS의 내용을 해석하고 노드를 만들어 트리 구조로 만든 것.
 - 자바스크립트 실행 (주의! HTML 중간에 스크립트가 있다면 HTML 파싱이 중단)
2. Style : 파싱 단계에서 생성된 DOM Tree와 CSSOM Tree를 조합해서 Render Tree를 구성한다. Render Tree는 실제로 화면에 그려질 Tree이다. 
    주의! `display: none` 속성과 같이 화면에서 보이지도 않고 공간을 차지하지 않는 것은 렌더트리로 구축되지 않는다
3. Layout : Rendering Tree에서 화면에 어떻게 배치해야 할 것인지 각 노드의 위치와 크기를 계산한다. 루트부터 노드를 순회하면서 노드의 정확한 크기와 위치를 계산하고 Render Tree에 반영하는데, 크기 값을 %로 지정하였다면 % 값을 계산해서 픽셀 단위로 변환한다.
  - 노드: 컴퓨터 과학에 쓰이는 기초적인 단위. 보통 네트워크에 연결되어있는 1개의 기기. 무언가를 연결하는 연결 지점. 네트워크에 연결되어있는 어떤 것이든 노드가 될 수 있으며 노드는 독립적으로 존재하지 않고 다른 노드와 연결되어있다. 링크라는 것을 통해 연결되는데 이 노드와 링크를 합쳐서 1개의 네트워크가 완성됨
4. Paint : 계산된 값을 이용해 각 노드를 화면상의 실제 픽셀로 변환하고 레이어를 만든다. 이때 픽셀로 변환된 결과는 하나의 레이어가 아니라 여러 개의 레이어로 관리된다.
5. Composite : 레이어를 합성하여 실제 화면에 나타낸다. 화면에서 웹 페이지를 볼 수 있다.

## HTML이 렌더링 중에 JavaScript가 실행되면 멈추는 이유
- 💡 렌더링 엔진은 HTML을 한 줄씩 순차적으로 [파싱](https://github.com/Esoolgnah/Frontend-Interview-Questions/blob/main/Notes/important-3/why-stop-rendering.md#gear-%ED%8C%8C%EC%8B%B1)하며 [DOM](https://github.com/Esoolgnah/Frontend-Interview-Questions/blob/main/Notes/important-3/why-stop-rendering.md#gear-dom) 트리 생성 
- JavaScript를 만나면 DOM 생성 임시 중단 
- 자바스크립트 코드를 파싱하기 위해 자바스크립트 엔진에 제어권을 넘깁니다. 
- 파싱이 끝나면 다시 렌더링 엔진에 제어권을 넘겨 중단된 부분부터 HTML 파싱을 재개하며 DOM 트리를 생성합니다.

</aside>

## Reflow와 Repaint가 실행되는 시점
```
Reflow : html의 레이아웃이 변경될 경우 레이아웃 단계에서 렌더 트리가 재생성되는데 이것을 리플로우라고 합니다. 레이아웃에 변화를 주는 거의 모든 속성이 리플로우를 유발합니다. 
Repaint : 가시성이 변경되는 순간 (opacity, background-color, visibility, outline), Reflow가 실행된 순간 뒤에 실행됩니다.
```
- Reflow : 브라우저 렌더링의 각 단계는 반드시 전 단계의 데이터가 필요하다. **이를 피하기 위해 GPU를 이용하는 transform 속성을 이용하여 레이아웃을 제어하는게 좋습니다.**
- DOM 엘리먼트 추가/제거/변경
- CSS 스타일 추가/제거/변경
- CSS 스타일을 직접 변경하거나, 클래스를 추가함으로써 레이아웃이 변경될 수 있다. 엘리먼트의 길이를 변경하면, DOM 트리에 있는 다른 노드에 영향을 줄 수 있다.
- CSS3 애니메이션과 트랜지션. 애니메이션의 모든 프레임에서 리플로우가 발생합니다.
- offsetWidth 와 offsetHeight 의 사용. offsetWidth 와 offsetHeight 속성을 읽으면, 초기 리플로우가 트리거되어 수치가 계산됩니다.
- 유저 행동. 유저 인터랙션으로 발생하는 hover 효과, 필드에 텍스트 입력, 창 크기 조정, 글꼴 크기 변경, 스타일시트 또는 글꼴 전환등을 활성화하여 리플로우를 트리거할 수 있다.

## 주소창에 google.com을 입력하면 일어나는 일
1. 사용자가 웹 브라우저를 통해 google.com 입력
2. URL 주소 중 도메인 네임 부분을 [DNS](https://github.com/Esoolgnah/Frontend-Interview-Questions/blob/main/Notes/important-5/what-happens-when-type-google.md#gear-dns) 서버에서 검색
3. DNS 서버에서 해당 도메인 네임에 해당하는 IP 주소를 찾아서 → 사용자가 입력한 [URL](https://github.com/Esoolgnah/Frontend-Interview-Questions/blob/main/Notes/important-5/what-happens-when-type-google.md#gear-url) 정보와 함께 전달
4. 브라우저는 [HTTP](https://github.com/Esoolgnah/Frontend-Interview-Questions/blob/main/Notes/important-5/what-happens-when-type-google.md#gear-http) [프로토콜](https://github.com/Esoolgnah/Frontend-Interview-Questions/blob/main/Notes/important-5/what-happens-when-type-google.md#gear-%ED%94%84%EB%A1%9C%ED%86%A0%EC%BD%9C)을 사용하여 요청 메시지 생성 → HTTP 요청 메시지는 [TCP](https://github.com/Esoolgnah/Frontend-Interview-Questions/blob/main/Notes/important-5/what-happens-when-type-google.md#gear-tcp)/[IP](https://github.com/Esoolgnah/Frontend-Interview-Questions/blob/main/Notes/important-5/what-happens-when-type-google.md#gear-ip) 프로토콜을 사용하여 서버로 전송
5. 서버는 [response](https://github.com/Esoolgnah/Frontend-Interview-Questions/blob/main/Notes/important-5/what-happens-when-type-google.md#gear-response) 메시지를 생성 → 다시 브라우저에게 데이터를 전송
6. 브라우저는 response를 받아 [파싱](https://github.com/Esoolgnah/Frontend-Interview-Questions/blob/main/Notes/important-5/what-happens-when-type-google.md#gear-%ED%8C%8C%EC%8B%B1) → 화면에 [렌더링](https://github.com/Esoolgnah/Frontend-Interview-Questions/blob/main/Notes/important-5/what-happens-when-type-google.md#gear-%EB%A0%8C%EB%8D%94%EB%A7%81)

## 호이스팅
💡 호이스팅이란 "끌어올린다" 라는 뜻으로 **변수 및 함수 선언문이 스코프 내의 최상단으로 끌어올려지는 현상** 을 말합니다. 여기서 주의할 점은 **"선언문"** 이라는 것이며 "대입문"은 끌어올려지지 않습니다. 실행 컨텍스트 생성 시 렉시컬 스코프 내의 선언이 끌어올려지는 게 호이스팅입니다.

```jsx
console.log(a);
var a = 2;

// 컴파일러는 자바스크립트 엔진이 인터프리팅 하기 전에 컴파일
// 이 때, `var a = 2;` 를 2개의 구문으로 봅니다.

var a
a = 2

// `var a` 는 변수 선언문으로 컴파일을 할 때 처리하고 `a = 2` 는 실행할 때까지 내버려둡니다
// 따라서, 변수 a는 호이스팅 되고 콘솔에는 다음과 같은 결과가 나옵니다.

undefined;

// var는 선언, 초기화가 동시에 이루어지기 때문에 undefined를 출력하지만
// let,const는 선언단계만 호이스팅 되기 때문에 Reference Error를 출력합니다.
```

[함수선언문](https://github.com/Esoolgnah/Frontend-Interview-Questions/blob/main/Notes/important-5/hoisting.md#gear-%ED%95%A8%EC%88%98%EC%84%A0%EC%96%B8%EB%AC%B8)의 경우도 호이스팅 됩니다. 함수 호이스팅에서 주의할 점: 함수표현식은 호이스팅 되지 않습니다.
```jsx
func();
function func() {
  console.log('함수 호이스팅');
}`

// 함수 호이스팅
```
- 함수선언문 : 변수를 선언하는 것(const,let 등)처럼 함수 선언은 function으로 시작합니다. 선언 된 함수는 나중 사용을 위해 저장되며, call 될 때 실행됩니다.
- 함수표현식 : 자바스크립트 함수는 표현식을 사용하여 정의 될 수 있으며, 함수 표현식은 변수로 저장될 수 있습니다. 함수 표현식이 변수에 저장되면, 변수는 함수처럼 사용 가능해집니다. 변수에 저장된 함수는 함수명이 필요 없으며, 변수 이름을 통하여 호출됩니다.

## 클로저
- 클로저는 값을 은닉하기 위해 사용하는 테크닉으로, 함수 안에 자식 함수를 만들고 밖으로 빼내서 외부에서 부모 함수의 스코프에 접근 할수 있도록 합니다. <br>
- 단점 : 비공개 프로퍼티를 만들기 때문에 사용하지 않는 메모리가 계속 차지하고 있는 ‘누수’ 현상이 일어난다. 클로저 안에 있는 변수는 사용자가 직접 메모리를 해제 해줘야한다.
- 함수가 속한 [렉시컬스코프](https://github.com/Esoolgnah/Frontend-Interview-Questions/blob/main/Notes/important-5/closure.md#gear-%EB%A0%89%EC%8B%9C%EC%BB%AC%EC%8A%A4%EC%BD%94%ED%94%84)를 기억하여 함수가 렉시컬 스코프 밖에서 실행될 때도 그 스코프에 접근할 수 있게 하는 기능

```jsx
function outer() {
  var a = 2;
  function inner() {
    console.log(a);
  }
  return inner;
}
var func = outer();
func(); // 2
```

여기서 GC([GarbageCollector](https://github.com/Esoolgnah/Frontend-Interview-Questions/blob/main/Notes/important-5/closure.md#gear-garbagecollector))가 `outer()` 의 참조를 없앨 것 같지만 내부함수인 `inner()` 가 해당 스코프의 변수인 a를 참조하고 있기 때문에 없애지 않습니다. 따라서 스코프 외부에서 `inner()` 가 실행되어도 해당 스코프를 기억하기 때문에 2를 출력하게 됩니다. 즉, 여기서 클로저는 `inner()` 가 되며 `func` 에 담겨 밖에서도 실행되고 렉시컬 스코프를 기억합니다.
위의 코드와 같은 방식으로 자바스크립트에는 없는 캡슐화라는 개념을 구현할 수 있고 정보 은닉과 캡슐화가 가져다주는 이점들을 얻을 수 있습니다.

## CSS Margin & Padding & 마진 병합
- margin: 바깥쪽 여백
- padding: 안쪽 여백
- **마진 컬렉싱** ? 인접하는 블록 요소의 상하단의 margin이 병합되는 현상입니다. 마진의 크기는 병합되는 마진 중 큰 값의 margin만 적용 됩니다. 부모 자식 사이에도 적용됩니다. 
이를 해결하기 위해서는 BFC(block formatting context)를 생성해야 합니다. block 레벨 요소들이나 float 된 요소들이 상호작용하여 화면에 보여지게 되는 방법(block formatting)을 결정하는 구역(context)을 말합니다. 인접한 요소들이 서로 다른 BFC에 속한다면 마진병합현상이 일어나지 않는데 부모 요소에게 overflow: hidden; 속성값을 적용하면 BFC가 부모요소 기준에서 생성, 해결

## CSS position
💡 position 속성은 문서 상에 요소를 배치하는 방법을 지정합니다 <br>
- `static` : 기본값, 요소를 일반적인 문서 흐름에 따라 배치
- `relative`: 자기 위치 기준으로 움직이고, 자신을 기준으로 `top`, `right`, `bottom`, `left`의 값에 따라 [오프셋](https://github.com/Esoolgnah/Frontend-Interview-Questions/blob/main/Notes/important-5/position.md#gear-%EC%98%A4%ED%94%84%EC%85%8B)을 적용
    - 예) position: relative; left : 50px; -> 본인의 static 자리에서 왼쪽으로 50px만큼 떨어진 자리에 위치하게 된다. 움직일때는 다른 콘텐츠들의 레이아웃에 영향을 미치지 않는다.
- `absolute`: static 아닌 position 가진 가장 가까운 조상 요소 기준
- `fixed`: 스크롤 내려도 뷰포트는 그대로 있는 부분, 바뀌지 않는 위치에 지정
    - 예) 스크롤을 내려도 상단의 검색 창은 사라지지 않고 뷰포트 상단에 고정되어 있는 모습, 뉴스창 로고 헤더
- `sticky` : (끈끈한, 끈적끈적한) 스크롤이 있어야 하고, 스크롤 내리다가 가장 가까운 부모 요소의 컨텐츠 영역에 달라붙는다. (IE 지원 X) 오로지 top만 적용된다
-----
- `static`: 요소를 일반적인 문서 흐름에 따라 배치합니다.
- `relative`: `static` + 자신을 기준으로 `top`, `right`, `bottom`, `left`의 값에 따라 [오프셋](https://github.com/Esoolgnah/Frontend-Interview-Questions/blob/main/Notes/important-5/position.md#gear-%EC%98%A4%ED%94%84%EC%85%8B)을 적용합니다.
- `absolute`: 요소를 일반적인 문서 흐름에서 제거하고, 가장 가까운 위치 지정 조상 요소에 대해 상대적으로 배치합니다.
- `fixed`: 요소를 일반적인 문서 흐름에서 제거하고, [뷰포트](https://github.com/Esoolgnah/Frontend-Interview-Questions/blob/main/Notes/important-5/position.md#gear-%EB%B7%B0%ED%8F%AC%ED%8A%B8)의 초기 [컨테이닝 블록](https://github.com/Esoolgnah/Frontend-Interview-Questions/blob/main/Notes/important-5/position.md#gear-%EC%BB%A8%ED%85%8C%EC%9D%B4%EB%8B%9D%EB%B8%94%EB%A1%9D)을 기준으로 삼아 배치합니다. => 바뀌지 않는 위치에 지정
- `sticky`: `static` + `fixed` 특징을 동시에 가집니다.
- z-index : 어떤 요소가 더 위로 나타나게 할지. static일 때는X
예) 위로 올라왔으면 하는 녀석에 z-index: 10; 값을 준다 (보통 10 20 30 10단위로 많이 주고, 숫자 값이 큰가 작은가가 중요함
값을 준 게 아니면 최근에 만들어진 것일 수록 가장 위에
부모가 자식을 덮어버릴 수는 없다
자식은 부모 뒤로 갈 수 있다 (마이너스값 -1 만 쓴다)

## REST API
💡 [REST](https://github.com/Esoolgnah/Frontend-Interview-Questions/blob/main/Notes/important-5/rest-api.md#gear-rest) 원칙을 적용하여 서비스 [API](https://github.com/Esoolgnah/Frontend-Interview-Questions/blob/main/Notes/important-5/rest-api.md#gear-api)를 설계한 것
REST API의 가장 큰 특징은 각 요청이 어떤 동작이나 정보를 위한 것인지를 그 요청의 모습 자체로 추론이 가능 <br>
- REST ?  REpresentational State Transfer
- [자원](https://github.com/Esoolgnah/Frontend-Interview-Questions/blob/main/Notes/important-5/rest-api.md#gear-%EC%9E%90%EC%9B%90)을 이름으로 구분하여 해당 자원의 상태를 주고받는 모든 것.
- HTTP [URI](https://github.com/Esoolgnah/Frontend-Interview-Questions/blob/main/Notes/important-5/rest-api.md#gear-uri)를 통해 자원을 명시하고, HTTP 메서드(POST, GET, PUT, DELETE)를 통해 해당 자원에 대한 [CRUD](https://github.com/Esoolgnah/Frontend-Interview-Questions/blob/main/Notes/important-5/rest-api.md#gear-crud)를 적용하는 것
- **REST 원칙의 특징**
    - 무상태 : **HTTP에서 서버가 클라이언트의 상태를 보존하지 않는 무상태 프로토콜이다.** 클라이언트 ***상태***를 보존하지 않고 통신을 하는 것이다.
- API ? Application Programming Interface
    - 응용 프로그램을 통해서 데이터를 제공받거나 기능을 사용하고자 할 때 사용하는 인터페이스.
    - 프로그램끼리 통신할 수 있도록 하는 중재자
    - 응용프로그램에서 사용할 수 있도록 운영 체제나 프로그래밍 언어가 제공하는 기능을 제어할 수 있게 만든 인터페이스

# this
함수를 호출하는 객체. **함수를 호출할 때 생성되는 실행 컨텍스트 객체**
this가 가리키는 대상은 어떻게 this가 호출되는지에 따라 다르다. (대부분 this의 값은 함수를 호출한 방법에 의해 결정된다.)
**전역 공간**에서의 this는 **전역 객체**를 가리킴. 
- 왜 사용할까?

```jsx
let myDinner = {
name: "김치찌개",
menu: function(){
	console.log("오늘 저녁은 " + myDinner.name);
	}
}
myDinner.menu(); // 오늘 저녁은 김치찌개
```

이런 객체가 있을 때 menu 함수는 myDinner 변수 이름이 수정될 경우 menu 함수 자체를 다른 객체에서 사용하고 싶을 때 사용이 불편해진다. this를 이용하면 global하게 다른 객체에서도 재사용할 수 있다.

```jsx
function menuGlobal() {
	console.log("오늘 저녁은 " + this.name);
}

let myDinner = {
name : "김치찌개",
menu : menuGlobal
}
myDinner.menu() // 오늘 저녁은 김치찌개

let yourDinner = {
name : "된장찌개",
menu : menuGlobal
}
yourDinner.menu() // 오늘 저녁은 된장찌개
```

- this는 호출 패턴에 따라 다른 객체를 참조합니다. 실행 컨텍스트([EC](https://github.com/Esoolgnah/Frontend-Interview-Questions/blob/main/Notes/important-4/this.md#gear-ec))가 생성될 때마다 this의 [바인딩](https://github.com/Esoolgnah/Frontend-Interview-Questions/blob/main/Notes/important-4/this.md#gear-%EB%B0%94%EC%9D%B8%EB%94%A9)이 일어나며 우선순위 순으로 나열해보면 다음과 같습니다.
1. `[new](https://github.com/Esoolgnah/Frontend-Interview-Questions/blob/main/Notes/important-4/this.md#gear-new)` 를 사용했을 때 해당 객체로 바인딩됩니다.

```jsx
var name = 'global';
function Func() {
  this.name = 'Func';
  this.print = function f() {
    console.log(this.name);
  };
}
var a = new Func();
a.print(); // Func
```

1. `[call](https://github.com/Esoolgnah/Frontend-Interview-Questions/blob/main/Notes/important-4/this.md#gear-call)`, `[apply](https://github.com/Esoolgnah/Frontend-Interview-Questions/blob/main/Notes/important-4/this.md#gear-apply)`, `[bind](https://github.com/Esoolgnah/Frontend-Interview-Questions/blob/main/Notes/important-4/this.md#gear-bind)` (와 같은 명시적 바인딩을) 사용했을 때 인자로 전달된 객체에 바인딩됩니다.

```jsx
function func() {
  console.log(this.name);
}
var obj = { name: 'obj name' };
func.call(obj); // obj name
func.apply(obj); // obj name
func.bind(obj)(); // obj name
```

1. 객체의 메소드로 호출할 경우 해당 객체에 바인딩됩니다.

```jsx
var obj = {
  name: 'obj name',
  print: function p() {
    console.log(this.name);
  },
};
obj.print(); // obj name
```

1. 그 외의 경우
- strict mode(엄격 모드): `undefined` 로 초기화됩니다.
    - 함수를 직접 호출해서 함수의 컨텍스트가 어디에 속하는지 알 수 없기 때문에
- 일반: 브라우저라면 `window` 객체에 바인딩됩니다.
- **호출 방식 / 가리키는 값**
    
    **일반 함수 / 전역객체**
    
    **메서드 / 메서드를 호출한 객체**
    
    **생성자 함수 / 생성자 함수가 생성할 인스턴스**
    
    **화살표 함수 / 상위 스코프**
    

- new ? 자바스크립트의 고유의 예약어이며 고유의 연산자(operator) 입니다. 아래는 자바스크립트의 new라는 연산자(operator)에 대한 정의 입니다. new 연산자는 사용자 정의 객체 타입 또는 내장 객체 타입의 인스턴스를 생성한다.
- bind ? ES5에서 추가, this값을 어디서 사용하든 호출 객체가 바뀌지 않게 고정시킴, this에 할당되는 객체가 고정된 새로운 함수 생성 / 함수의 첫 번째 인자에 this를 바인딩한다는 점은 같지만, 함수를 실행하지 않으며 새로운 함수를 반환합니다. 즉 반환된 새로운 함수를 실행해야 원본 함수가 실행됩니다.
- call ? this 값을 바꿀 수도 있고 함수 실행할 때 사용할 인수도 전달할 수 있다. / call을 사용하면 함수를 실행하고 함수의 첫 번째 인자로 전달하는 값에 this를 바인딩합니다.
- apply ?  함수를 실행할 때 인수를 배열에 묶어 한번에 전달 / call과 마찬가지로 apply를 사용하면 함수를 실행하고 함수의 첫 번째 인자로 전달하는 값에 this를 바인딩합니다. call과의 차이점은 인자를 배열의 형태로 전달한다는 것입니다. 이 때, 인자로 배열 자체가 전달되는 것이 아니라, 배열의 요소들이 값으로 전달됩니다.
- call()과 apply()의 차이
    - call : 함수 실행할 때 전달할 인수를 하나하나 전달
    - appy : 전달할 인수를 배열로 묶어 한번에 전달, 그래서 인수를 두 개만 사용인수를 배열로 보낸다는 점 빼고 동일한 기능 수행
      
## 브라우저 저장소의 차이점
- **LocalStorage**
    - 로컬 스토리지는 저장한 데이터를 지우지 않는 이상 영구적으로 보관이 가능합니다. [도메인](https://github.com/Esoolgnah/Frontend-Interview-Questions/blob/main/Notes/important-4/web-storage.md#gear-%EB%8F%84%EB%A9%94%EC%9D%B8)마다 별도로 로컬 스토리지가 생성됩니다.
    - 최대 크기: 5MB
    - 사용 예시: 자동 로그인
- **SessionStorage**
    - 세션 종료 시 클라이언트에 대한 정보가 삭제됩니다.
    - 최대 크기: 5MB
    - 사용 예시: 입력 폼 정보, 비로그인 장바구니
- **[쿠키](https://github.com/Esoolgnah/Frontend-Interview-Questions/blob/main/Notes/important-4/web-storage.md#gear-%EC%BF%A0%ED%82%A4)(Cookie)**
    - 쿠키는 클라이언트 **로컬**에 저장되는 키와 값 형태의 작은 파일로, 4KB까지 저장이 가능합니다. 만료 기간을 설정할 수 있고 지속적인 데이터 교환을 위해 만들어졌습니다.
    - 클라이언트가 웹 사이트에 접속할 때, 그 사이트가 사용하게 되는 일련의 작은 파일 기록 (인터넷 사용자가웹 사이트를 방문할 경우 그 사이트가 사용하고 있는 서버를 통해 인터넷 사용자의 컴퓨터에 설치되는 작은 기록 정보)
    - 웹 사이트에서 쿠키를 설정하면, 모든 웹 요청에는 쿠키 정보가 포함됩니다. => 서버 부담 증가
    - 서버가 클라이언트에 정보를 전달할 때 저장하고자 하는 정보를 응답헤더(cookie)에 저장해서 전달(보안 취약), 서버 부담 증가
    - 사용자 인증이 유효한 시간을 명시할 수 있고, 유효시간이 정해지면 브라우저가 종료되어도 인증이 유지된다.
    - 최대 크기: 4KB
    - 사용 예시: 팝업 창
- **서버 인증과 브라우저 저장소**
    - 주요 정보를 요청 헤더에 넣는 방법 : 보안에 매우 취약합니다.
    - Session, Cookie 방식 : 서버 부하가 증가하고, 세션 하이재킹 공격에 취약합니다.
- 세션은 서버에서 가지고 있는 정보, 쿠키는 사용자에게 발급된 세션을 열기 위한 열쇠(SESSION ID)
결과적으로 인증의 책임을 서버가 지게하기 위해 세션을 사용(사용자가 해킹당하는 것보단 서버가 해킹당하는게 훨씬 어려우니까) 사용자는 쿠키를 이용하고, 서버에서는 쿠키를 받아 세션의 정보를 접근하는 방식으로 인증
- 웹스토리지는 로컬스토리지와 세션스토리지를 통틀어서 지칭하는 말이며 **내부적으로는 영구저장소(LocalStorage)와 임시저장소(SessionStorage)가 분리되어 데이터 지속성에 따라 선택적으로 사용이 가능하다.**
- **[JWT](https://github.com/Esoolgnah/Frontend-Interview-Questions/blob/main/Notes/important-4/web-storage.md#gear-jwt) 방식 (JSON Web Token)**
    - JSON 포맷을 사용하여 인증에 필요한 정보들을 토큰에 담아 암호화시켜 사용하는 토큰.
    - 장점 : 별도의 브라우저 저장소에 저장하지 않고 JWT를 발급하고 검증하면 되어서 확장성이 뛰어납니다.
    - 단점 : Payload(전송되는 데이터)는 암호화되지 않기 때문에 디코딩하면 누구나 정보를 확인할 수 있고  유저의 중요한 정보들은 *Payload*에 넣을 수 없다, JWT 길이가 길다

## Restful API (GET, PUT, POST, PATCH, OPTION, DELETE)
💡 [REST API](https://github.com/Esoolgnah/Frontend-Interview-Questions/blob/main/Notes/important-5/rest-api.md)를 제공하는 웹사이트를 RESTful 하다고 할 수 있습니다. RESTful API를 통해 이해하기 쉬운 API를 만드는 것이 목적입니다.
- GET: 요청받은 URI의 정보를 검색하여 응답합니다.
- POST: 요청된 자원을 생성합니다.
- DELETE: 요청된 자원을 삭제할 것을 요청합니다.
- PUT: 요청된 자원을 (전체를) 수정합니다.
- PATCH: 요청된 자원 (일부를) 수정합니다.
- HEAD: GET 방식과 동일, 하지만 응답에 BODY가 존재하지 않으며, 응답코드와 HEAD 만 응답합니다.
- CONNECT: 동적으로 터널모드를 교환, 프록시 기능을 요청시 사용합니다.
- TRACE: 원격지 서버에 루프백 메세지를 호출하기 위해 테스트용으로 사용합니다.
- OPTIONS: 웹서버에서 지원되는 메서드의 종류를 확인할 경우 사용합니다.

## JavaScript는 어떤 언어일까?
💡 JavaScript는 `싱글 스레드`이면서 `논 블록킹` 언어 <br>
싱글 스레드 논 블록킹 : 자바스크립트는 비동기 처리를 통해 싱글 스레드이지만 블록킹 되지 않게 합니다. 하나의 요청이 완료될 때까지 기다리지 않고 동시에 다른 작업을 수행함으로써 문제를 해결합니다.

## 자바스크립트 동작 원리 Event Loop ***
💡 자바스크립트는 싱글 스레드 기반의 언어, 자바스크립트가 구동되는 환경(Node.js, 브라우저)은 여러 스레드가 사용됨. **여러 스레드가 사용되는 구동 환경이 자바스크립트 엔진과 연동하기 위해 사용되는 장치가 '이벤트 루프'** 이벤트 루프는 **스레드 안에 있는 코드들을 스케쥴링하고 실행시키는 역할**을 담당 <br>

💡 일반적인 작업은 콜스택(Call Stack)에서 이루어집니다. <br>
→ 시간이 소요되는 작업들(setTimeout, 이벤트, HTTP 요청 메서드 등)은 WebAPI에서 대기하다가  <br>
콜백큐(Callback Queue)로 보내집니다. <br>
→ call stack이 다 비워지면 callback queue에 저장되어있던 함수를 하나씩 call stack으로 옮기는 역할을 하는 게 Event Loop

## 마이크로 태스크 큐, (매크로) 태스크 큐
💡 2개의 큐 모두 [콜백함수](https://github.com/Esoolgnah/Frontend-Interview-Questions/blob/main/Notes/important-4/microtask-queue-task-queue.md#gear-%EC%BD%9C%EB%B0%B1%ED%95%A8%EC%88%98)가 들어간다는 점에서 동일하며, 어떤 함수를 실행하느냐에 따라 어디로 들어가는지가 달라집니다. [이벤트 루프](https://github.com/Esoolgnah/Frontend-Interview-Questions/blob/main/Notes/important-4/event-loop.md)는 각 콜백함수를 태스크/마이크로태스크 큐에서 꺼내쓰는 것인데, 차이는 작업의 우선순위고 `마이크로태스크 큐가 먼저입니다.` [이벤트 루프](https://github.com/Esoolgnah/Frontend-Interview-Questions/blob/main/Notes/important-4/event-loop.md)는 마이크로태스크 큐의 모든 태스크들을 처리한 다음, 매크로태스크 큐의 태스크들을 처리합니다. `Promise`의 콜백함수가 `setTimeout()`의 콜백함수보다 먼저 처리됩니다.
(콜백큐 = 매크로 태스크 큐 = 태스크 큐)
- 콜백함수를 마이크로 태스크 큐에 넣는 함수들
    - process.nextTick, Promise, Object.observe, MutationObserver
- 콜백함수를 (매크로) 태스크 큐에 넣는 함수들
    - setTimeout, setInterval, setImmediate, requestAnimationFrame, I/O, UI 렌더링

## 이벤트 전파 ***
💡 이벤트 전파란 이벤트가 전달되는 단계 또는 순서입니다. 특정 요소에 대한 이벤트가 발생하면 해당 요소에 할당된 이벤트 핸들러가 동작하게 되는데 이 때 핸들러가 동작하면서 버블링(bubbling)과 캡처링(capturing)이 발생하게 됩니다. **생성된 이벤트 객체는 이벤트를 발생시킨 DOM 요소인 이벤트 타깃을 중심으로 DOM 트리를 통해 전파**
- 이벤트 캡처링 : 이벤트가 상위 요소에서 하위 요소 방향으로 전파
- 타겟 : 이벤트가 실제 타깃 요소에 전달되는 타깃 단계
- 이벤트 버블링 : 이벤트가 하위 요소(p)에서 상위 요소(div) 방향으로 전파 (일반적)
- 이벤트 전파 막기
    - [e.stopPropagation()](https://github.com/Esoolgnah/Frontend-Interview-Questions/blob/main/Notes/important-4/event-bubbling.md#gear-stoppropagation) : 버블링 단계에서 상위 요소로 이벤트가 전달되지 못하게 막아줍니다.
    - ****e.stopImmediatePropagation() :**** 상위 요소로 전파를 하지 못하게 방지해 주며 **형제 요소**의 이벤트 전파도 방지해 줍니다. 자식 요소에 2개의 이벤트가 걸려 있을 때 부모 요소의 전파를 막아주고 자식 요소의 첫 번째 이벤트만 작동을 합니다.
    - e.preventDefault() : 태그의 고유 동작을 취소시킵니다

## 이벤트 위임 ***
이벤트 위임이란 하위 요소마다 이벤트를 붙이지 않고 상위 요소에서 하위 요소의 이벤트들을 제어하는 방식을 말한다. **이벤트 위임을 사용하면 요소마다 핸들러를 할당하지 않고, 요소의 공통 조상에 이벤트 핸들러를 단 하나만 할당해도 여러 요소를 한꺼번에 다룰 수 있다.**
- 예) 예를들어 위의 *nav* 예시에서, 메뉴를 눌렀을때 메뉴에 맞는 섹션으로 이동하는 스크롤 기능을 추가한다고 하자. 문제는 element마다 이벤트 핸들러를 추가하므로 여기서는 element가 세개지만 만약 리스트 아이템이 많아진다면 비효율적이다. 이 번거로운 작업을 해결할 수 있는 방법이 바로 이벤트 위임이다. 먼저 **공통의 부모요소에 이벤트리스너를 추가**하고 이벤트리스너 안에서 어떤 요소가 이벤트를 발생시켰는지 확인한다.

## 타입스크립트
💡 타입을 명시하지 않는 자바스크립트와 달리, 타입스크립트를 통해 [정적 타입](https://github.com/Esoolgnah/Frontend-Interview-Questions/blob/main/Notes/important-4/type-script.md#gear-%EC%A0%95%EC%A0%81%ED%83%80%EC%9E%85)을 명시하여 사용할 수 있습니다.
* 타입스크립트의 장점
타입스크립트는 코드에 목적을 명시하고, 목적에 맞지 않는 타입의 변수나 함수에서 에러를 발생시켜 버그를 사전에 제거할 수 있습니다. 프로젝트가 크고 복잡할수록 타입스크립트가 가진 강점이 더 커진다.
- TypeScript의 가장 독특한 특징은 정적 타이핑을 지원한다는 것입니다. 정적 타입 언어는 타입을 명시적으로 선언하며, 타입이 결정된 후에는 타입을 변경할 수 없습니다. 잘못된 타입의 값이 할당 또는 반환되면 컴파일러는 이를 감지해 에러를 발생시킵니다.
- 자바스크립트는 동적 타입(dynamic typed) 언어 혹은 느슨한 타입(loosely typed) 언어입니다. 이것은 변수의 타입 선언 없이 값이 할당되는 과정에서 동적으로 타입을 추론(Type Inference)한다는 의미입니다. 동적 타입 언어는 타입 추론에 의해 변수의 타입이 결정된 후에도 같은 변수에 여러 타입의 값을 교차하여 할당할 수 있습니다. 이를 동적 타이핑(Dynamic Typing)이라 합니다. 동적 타이핑은 사용하기 간편하지만 코드를 예측하기 힘들어 예상치 못한 오류를 만들 가능성이 높습니다. 또한 IDE와 같은 도구가 변수나 매개 변수, 함수의 반환값의 타입을 알 수 없어 코드 어시스트 등의 기능을 지원할 수 없게 합니다

## 실행문맥(실행 컨텍스트) ***
💡 **실행할 코드에 제공할 환경 정보(코드 실행에 영향을 주는 조건이나 상태)들을 모아놓은 객체** 
- 동일한 환경에 있는 코드들을 실행할 때 필요한 환경 정보들을 모아 객체를 구성 → 이를 콜 스택에 쌓아올렸다가 → 가장 위에 쌓여있는 컨텍스트와 관련 있는 코드들을 실행하는 식 
- 전체 코드의 환경과 순서를 보장 (실행 컨텍스트들은 실행 컨텍스트 스택에 하나씩 쌓이고 사라진다.)
- 어떤 실행 컨텍스트가 활성화되는 시점에 선언된 변수를 위로 끌어올리고 외부 환경 정보를 구성하고, this 값을 설정하는 등의 동작을 수행합니다. 실행 컨텍스트는 자바스크립트의 동적 언어로서의 성격을 가장 잘 파악할 수 있는 개념입니다. 만약 실행 컨텍스트를 구성하고 싶다면, 함수를 실행해보면 됩니다.
- 소스코드 평가 과정에서는 선언문이 실행되고, 스코프에 등록된다. 소스코드 실행 과정에서는 변수에 값이 할당되고 함수가 호출된다.

## SPA, CSR, SSR의 차이 ***
- **SPA : 싱글 페이지 애플리케이션** 최초 한번 페이지 전체 로딩 → 데이터만 변경해서 사용할 수 있는 웹 애플리케이션, 하나의 페이지에서 실행
- **CSR : 클라이언트 사이드 렌더링** 렌더링이 클라이언트 쪽에서 일어난다. 서버는 요청을 받으면 클라이언트에 HTML과 JS를 보내준다. 클라이언트는 그것을 받아 렌더링을 시작한다. 사용자의 [인터렉션](https://github.com/Esoolgnah/Frontend-Interview-Questions/blob/main/Notes/important-4/spa-scr-ssr.md#gear-%EC%9D%B8%ED%84%B0%EB%A0%89%EC%85%98)에 따라서 클라이언트단에서 받아와 렌더링을 해주는 방식
- **SSR : 서버 사이드 렌더링** 서버에 새로운 페이지에 대한 요청을 하는 방식 → 요청시마다 새로고침이 일어난다

- **CSR**
1. 검색 엔진은 자동화된 로봇인 '크롤러'로 웹 사이트들을 읽는다. CSR은 자바스크립트를 실행시켜 동적으로 컨텐츠가 생성되기 때문에 SEO에 취약
2. HTML, CSS와 모든 스크립트들을 한 번에 불러오기 때문에 초기 화면의 렌더링 속도가 느리다.
3. 이미 첫 페이지 로딩할 때 나머지 부분을 구성하는 코드를 받아왔기 때문에 렌더링 속도가 빠르다.
- **SSR**
1. 서버 사이드에서 컴파일되어 클라이언트로 넘어오기 때문에 SEO 최적화
2.  (필요한 부분만 불러와서) 초기 화면의 렌더링 속도가 빠르다.
3. 매 랜더링마다 서버를 거치기 때문에 속도가 느리다.

## require와 import의 차이점
💡 기본적으로 require와 import는 모듈 키워드입니다. 외부 파일이나 라이브러리를 불러올 때 사용합니다. 두 개 같이 사용할 수 없습니다.
`require`는 [CommonJS](https://github.com/Esoolgnah/Frontend-Interview-Questions/blob/main/Notes/important-3/require-import.md#gear-commonjs)를 사용하는 node.js문이지만 `import`는 ES6에서 도입된 키워드입니다. <br>
`require`는 파일(non-lexical,비어휘적)에 저장된 위치에 남아 있으며 `import`는 항상 맨 위로 이동합니다. <br>
`require`는 프로그램의 어느 지점에서나 호출 할 수 있지만 `import`는 파일의 시작 부분에서만 실행할 수 있습니다. (하지만 import전용 비동기 문법으로 처리 가능)
일반적으로 `import`는 사용자가 필요한 모듈 부분만 선택하고 로드 할 수 있기 때문에 더 선호됩니다. 이 명령문은 `require`보다 성능이 우수하며 메모리를 절약합니다.
- 최근 ES6(ES2015) 모듈 시스템인 `import` 가 많이 사용되고 있지만, 그러나 아직까지는 `import` 키워드가 100% 대체되어 사용될 수 없습니다. **Babel과 같은 ES6 코드를 변환(transpile)해주는 도구를 사용할 수 없는 경우에는 `require` 키워드를 사용해야 합니다.**
- CommonJS 란? 웹 브라우저 밖의 자바스크립트를 위한 모듈 생태계의 규칙을 설립하기 위한 프로젝트입니다. 개념은 간단합니다. '.js' 파일 간의 어떻게 의존성을 가지게 할지 정해주는 것입니다. commonJS라는 개념이 존재하는 이유는 자바스크립트를 범용적으로 모듈화를 높이기 위해서입니다.

## var,let,const 차이
- `var` 변수 중복선언, 재할당 모두 가능
    `let` 변수 중복선언 불가능, 재할당 가능
    `const` 변수 중복선언, 재할당 모두 불가능
- `var` 함수레벨 스코프
`let`, `const` 블록레벨 스코프
- `var` 호이스팅시 변수 초기화 되어 undefined
`let` 선언-TDZ-초기화-할당 (호이스팅이 발생했으나 값을 참조할 수 없기 때문에 호이스팅이 이뤄지지 않는 것처럼 보인다. '선언 단계'와 '초기화 단계'가 분리되어 진행된다.) 값을 할당하기전에 변수가 선언 되어있어야 하는데 그렇지 않기 때문에 에러가 난다.
`const`  let과 마찬가지인데 좀 더 엄격. TDZ로 인한 제약을 받는다. 
초기화 이전 접근시 ReferenceError 발생
- `var`로 선언한 변수는 전역객체(브라우저 환경에서 window)의 프로퍼티(속성)로 할당된다. 전역 객체를 사용하면 어디서나 사용할 수 있는 변수나 함수를 만들 수 있다.
`let`, `const`로 선언한 변수는 전역 객체의 property가 아니다.

## SASS(SCSS)를 사용해본 적이 있나요? 기존 CSS와 비교할 때 어떤 면이 더 좋은가요?
- 간편한 변수 사용가능
- Nesting 기능 : 중첩해서 선언 가능, 상위요소 참조시에는 &(앰퍼샌드) 문자 사용
- `@extend`  지시어를 사용하여 특정 선택자의 속성을 상속받을 수 있다
- `@import` 지시어를 사용해서 다른 scss 파일을 import할 수 있다

## CORS에 대처하는 방법과 우회하는 방법 ***
💡 * Cross-Origin Resource Sharing ? 교차 출처 자원 공유. **브라우저에서 다른 출처의 리소스를 공유하는 방법** (웹 브라우저에서 외부 도메인 서버와 통신하기 위한 방식을 표준화한 스펙. 서버와 클라이언트가 정해진 헤더를 통해 서로 요청이나 응답에 반응할지 결정)
- 외부 서버로 ajax 요청이 안될 경우 아래와 같은 단계로 처리
1. 개발자가 테스트 혹은 개발단계에서 쉽게 요청하기: [웹 브라우저 실행 옵션](https://github.com/Esoolgnah/Frontend-Interview-Questions/blob/main/Notes/important-3/how-to-handle-cors-error.md#gear-%EC%9B%B9%EB%B8%8C%EB%9D%BC%EC%9A%B0%EC%A0%80%EC%8B%A4%ED%96%89%EC%98%B5%EC%85%98)이나 [플러그인](https://github.com/Esoolgnah/Frontend-Interview-Questions/blob/main/Notes/important-3/how-to-handle-cors-error.md#gear-%ED%94%8C%EB%9F%AC%EA%B7%B8%EC%9D%B8)을 통한 [동일 출처 정책](https://github.com/Esoolgnah/Frontend-Interview-Questions/blob/main/Notes/important-3/how-to-handle-cors-error.md#gear-%EB%8F%99%EC%9D%BC%EC%B6%9C%EC%B2%98%EC%A0%95%EC%B1%85) 회피
2. CORS 구현이 안되어 있는 서버로 ajax 요청을 해야하지만 서버 쪽 컨트롤이 불가능할 경우: [**jsonp방식](https://github.com/Esoolgnah/Frontend-Interview-Questions/blob/main/Notes/important-3/how-to-handle-cors-error.md#gear-jsonp%EB%B0%A9%EC%8B%9D)으로 요청**
3. Ajax 요청을 해야 하는 다른 도메인의 서버를 클라이언트와 같이 개발하거나 서버 개발 쪽 수정 요청이 가능한 경우: [서버에서](https://github.com/Esoolgnah/Frontend-Interview-Questions/blob/main/Notes/important-3/how-to-handle-cors-error.md#gear-%EC%84%9C%EB%B2%84%EC%97%90%EC%84%9C) CORS 요청이 허용되도록 구현
- 동일 출처 정책(Same-Origin Policy) : 어떤 출처에서 불러온 문서나 스크립트가 다른 출처에서 가져온 리소스와 상호작용하는 것을 제한하는 중요한 보안 방식. 잠재적으로 해로울 수 있는 문서를 분리함으로써 공격받을 수 있는 경로를 줄여줍니다.
- jsonp방식 : 웹 브라우저에서 css나 js 같은 리소스 파일들은 동일 출처 정책에 영향을 받지 않고 로딩이 가능합니다. 이런 점을 응용해서 외부 서버에서 읽어온 js 파일을 json으로 바꿔주는 일종의 편법적인 방법입니다. 단점은 리소스 파일을 GET 메서드로 읽어오기 때문에 GET 방식의 API만 요청이 가능합니다.
- **프로토콜, 호스트, 포트가 같아야 같은 출처고, 그게 다르면 다른 출처**

## React의 라이프 사이클
💡 리액트는 컴포넌트 기반의 View를 중심으로 한 라이브러리입니다. 각각의 컴포넌트에는 라이프 사이클 즉, 컴포넌트의 생명 주기가 존재합니다. 컴포넌트의 생명은 보통 페이지에서 렌더링되기 전인 준비 과정에서 시작하여 페이지에서 사라질 때 끝이 납니다. 컴포넌트는 `생성 => 업데이트 => 제거`의 생명 주기를 갖고 있습니다.
- 마운트(생성) : 컴포넌트의 첫 렌더링 / 컴포넌트의 [인스턴스](https://github.com/Esoolgnah/Frontend-Interview-Questions/blob/main/Notes/important-3/gear-)가 생성되어, DOM에 삽입될 때 순서대로 호출됩니다.
- 업데이트 : props나 state가 변경되면 렌더(갱신)가 진행되며 순서대로 호출됩니다.
- 언마운트(제거) :  페이지에서 사라질 때 끝이 납니다
