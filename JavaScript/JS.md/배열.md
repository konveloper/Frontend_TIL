# 배열

데이터 구조? 데이터의 집합

배열? 값의 순서 있는 집합.

칸마다 넣어두는 일주일 약통 같은 것! (순서가 있음)
배열도 인덱스가 0부터 시작함

```jsx
let colors = []; → 빈 배열
let colors = [’red’, ‘orange’, ‘navy’]
colors // (3) [’red’, ‘orange’, ‘navy’]
colors.length // 3
colors[0] // ‘red’
colors[0][1] // ’r’
```

- 특정 문자를 바꿀 수 없었던 문자열과 달리 배열은 요소를 바꾸는 게 가능하다!

```jsx
colors[0] = ‘pink’
colors // (3) ['pink', 'orange', 'navy']

기존에 없어도 추가도 가능하다 color[3] = ‘black’
```

- push → add to end

새 배열을 반환한다

```jsx
let movieLine = [’tom’, ‘nancy’]
movieLine.push(’oliver’)
movieLine //  (3)[’tom’, ‘nancy’, ’oliver’]
```

- pop → remove from end

```jsx
movieLine.pop() // ‘oliver’
movieLine // (2) ['tom', 'nancy']
let person = movieLine.pop()
person // ‘nancy’

movieLine // [’tom’]
```

- shift → remove from start

```jsx
movieLine // (2) ['tom', 'nancy']
movieLine.shift() // 'tom'
movieLine // ['nancy']
```

- unshift → add to start 이름 헷갈리지 마세요…

```jsx
movieLine.unshift(’VIP’)
movieLine // (2) ['VIP', 'nancy']
```

- concat

2개를 합쳐서 제 3의 새 문자열 만들기 (기존 배열 수정X)

```jsx
let cats = [’blue’, ‘kitty’]
let dogs = [’rusty’, ‘boo’]
let comboParty = cats.concat(dogs) // [’blue’, ‘kitty’, ’rusty’, ‘boo’]
```

- includes

배열에 특정 값이 포함되어있는지 boolean 값으로 

```jsx
cats.includes(’blue’) // true
```

- indexOf (첫번째 요소만 찾아서 보여준다)

```jsx
comboParty.indexOf(’rusty’) // 2
```

- reverse

그 자리에서 원본의 배열을 뒤집어준다

```jsx
comboParty.reverse()
```

- slice

배열의 일부를 복사

```jsx
let colors = [’red’, ‘orange’, ‘yellow’, ‘green’]
colors.slice(2) // [‘yellow’, ‘green’]
let warmColors = colors.slice(0,3) // (3) ['red', 'orange', 'yellow']
// 인덱스를 음수로 쓰면 배열의 끝에서부터 시작
colors.slice(-3) // (3) ['orange', 'yellow', 'green']
```

- splice

원본의 기존 요소를 대체 제거, 새로운 요소를 추가
배열 중간값 업데이트는 비효율적이고, 제거할 때 사용한다

```jsx
.splice(1,2) // 1번째 인덱스에서부터 2개 삭제
.splice(1,0,’추가’) // 1번째 인덱스 자리에 0개를 제거하고 ㅇㅇ를 추가
```

- sort

작은 것에서 큰 것으로 … 정렬

- 자스는 배열 안에 있는 건 관심이 없고, 실제로 비교하는 건 메모리가 참조하는 값이다 ! 
두 배열의 콘텐츠가 같아도 참조하는 값은 다르다
두 배열을 비교하려면 같은 참조를 따르는 배열인지 확인해야한다
- const 참조를 바꾸거나 재할당 할 수는 없지만 배열 안의 콘텐츠는 원하는 대로 바꿀 수 있다
- 중첩 배열 : []로 연결, 인덱스로 접근
