# 기초

- HTML, CSS, JavaScript는 브라우저가 이해하고 브라우저를 위해 사용하는 세 가지 주요 도구
- 예) 구글에서 닭을 검색 → 구글 서버로 HTTP 요청이 전달 → 구글 서버 중 하나가 검색어인 닭을 분석, 검색 결과를 만든다 → 검색결과 페이지는 HTML, CSS, JavaScript로 구성된다 → 브라우저로 전달되어 검색 결과가 나타난다
- JS는 동작을 담당하는 동사와 같다!
- 콘솔창 열기 cmd + option + J
    - 위쪽 화살표 키를 누르면 이전 연산 기록을 볼 수 있다
    - cmg + K 콘솔창 클리어
    - // 주석
      
 <br>
 
- 자스는 프로그래밍 언어. 개발자는 정해진 문법으로 특정한 로직을 수행하도록 프로그래밍한다. 어떤 환경에 어떤 일을 수행하느냐에 따라 적절한 언어를 선택해야한다. 자스는 브라우저 환경에서 많이 쓰이고, 브라우저 외부 컴퓨터에서도 많이 쓴다. 하지만 자스만으로는 할 수 있는게 많이 없다. 언어는 특정한 문법을 가지고 있는, 어떤 어플리케이션을 만드는 데 있어서 필요한 로직을 나타낼 수 있는 도구에 불과하다. 언어는 문법만 들어있다! 무언가를 출력하고 싶다면, 통신하고싶다면, 다양한 일을 하려면 외부환경(라이브러리)가 필요하다.
- 프엔 개발자라면! 프엔 지식(웹이 뭔지, 웹사이트 구조는 어떻게 가져와야하며)을 가지고, 필요한 로직을 프로그래밍화하고, 코딩할 수 있어야 하며, 브라우저에서 제공해주는 다양한 웹 API를 알아야 한다.
  
 <br>
 
## 자바스크립트 엔진
- 자스 언어가 브라우저와 컴퓨터 위에서 어떻게 동작? 자스 코드가 실행되려면 자바스크립트 엔진이 필요하다! 브라우저 자체에 내장되어있는 자바스크립트 엔진이 우리의 Js파일을 동작하는 시기,과정(런타임)에서 코드를 한줄한줄 읽어서 실행해준다(인터프리터:런타임시 코드를 한줄씩 번역해서 실행) 다른 컴퓨터 언어에서는 컴파일러 compiler...
- 예) 자바 코드 실행하려면 컴파일러 통해서 모든 코드를 컴퓨터가 이해할 수 있는 실행파일로 바꿔준다(컴파일링) 실행하기 전 모든 코드를 컴파일링!!
- 단점: 처음에 컴파일링하는게 오래걸린다 / 장점 : 이미 컴파일링 해놔서 실행 속도 빠름
- 자스의 인터프리터는 일단 실행해놓고 필요하면 한줄한줄 번역해서 실행
- 장점: 일단 실행은 해놓기 때문에 빠름 / 단점 : 실행되는 당시에는 한줄한줄 번역하니 실행 속도가 느림
- 각 브라우저마다 다른 엔진을 가지고 있다
    - IE - Chakra
    - 크롬 - V8
    - 엣지 - V8 (컴퓨터에서 자스 사용하게 해주는 노드js도 V8엔진 사용)
    - 사파리 - JavaScript Core
    - 파이어폭스 - SpiderMonkey
- ECMAScript : 자스 문법 규격사항, 표준사항. 이 문법 정의를 이용해서 코딩할 때도 프로그래밍하고 엔진도 이렇게 맞게 구현한다. 서로 호환하게끔!

## 변수 Variable 선언 및 할당 
(데이터를 선언하고 정의하고! 프로그래밍의 가장 기본)

- 컴퓨터를 구성하는 3가지 핵심 요소
    - 하드디스크(파일,어플리케이션을 저장하는 장치)
    - CPU (장치로부터 데이터를 읽어와서 처리)
    - 메모리 (하드디스크에서 읽고 쓰는 건 오래 걸리므로 데이터를 임시적으로 빠르게 읽고 쓰기 위해 올려두는)
- 문서를 연다? -> 하드디스크에 저장된 폴더 안에서 파일 선택 -> 어떤 걸 선택하고 열고 계산을 CPU가 처리 -> 하드디스크에 있는 문서 파일의 데이터를 메모리상으로 가져온다 -> 파일을 열고 처리할 수 있는 어플리케이션을 모니터에 연다 -> 사용자가 수정하는 내용을 메모리상에 주기적으로 업데이트하면서 여러 작업을 처리 -> 작업한 내용을 저장하고 어플리케이션을 종료 -> 메모리상 데이터를 하드디스크에 다시 저장
- 어플 실행시 큰 3가지 일이 연속적으로 발생
    - 입력 input (사용자가 데이터를 클릭하거나 입력)
    - 처리 Process (작성한 코드, 주어진 로직대로)
    - 출력 output (모니터에 보여주거나/파일시스템 쿠키 스토리지 등에 저장되거나/네트워크 통신 통해서 다른 백엔이나 서버로 보내거나...)
- 가장 기본적인 것은 처리! 데이터를 임시적으로 보관하기 위한 변수가 필요하다.
- 변수? 값을 저장하는 공간, 자료를 저장할 수 있는 이름이 주어진 기억장소
- `let a = 0;` a라는 변수 선언하고 0이라는 값을 할당하면 메모리상 어딘가에 0이라는 값이 저장 -> 각각 메모리 셀마다 해당하는 메모리 주소가 있음 -> a라는 변수이름이 메모리 주소를 가리키고 있다. 그러나 메모리 주소 자체를 변수로 쓰면 너무 길고 어떤 데이터를 담고 있는지도 모른다. 메모리 주소 대신 가리키는 변수 이름(variable name)을 사용한다. 혹은 식별자(identifirer). 포스트잇과 같은 것.
- Naming 저장된 값을 잘 나타낼 수 있는 의미있는 이름! 구체적일수록 좋다!
    - [변수 MDN 문서](https://developer.mozilla.org/ko/docs/Learn/JavaScript/First_steps/Variables)
    - [예약어 종류](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Lexical_grammar#keywords)
- 변수 규칙
    - 라틴문자(0-9, a-z, A-Z)
    - 대소문자 구분
    - 추천: camelCase
    - 변수명 한국어 X 영어 O
    - 예약어 X
    - 숫자 시작 X
    - 특수문자 X (_, $ 두 가지는 예외)
    - 이모지 X
    - 여러개 변수를 1,2,3 숫자로 구분 X -> 최대한 구체적으로 의미있게!
- 나쁜 예제
    - let number; -> let myAge;
    - let audio1;
    - let audio2;
    -> let backgroundAudio;
- 꿀팁
    - let audioBackground;
    - let audioWind;
    - 뭔지를 앞으로 빼고 구체적인 부분을 뒤로 쓰면 audio치면 변수명 좌르륵 뜨니까 이렇게 작성하면 협업에서도 편함
 
## 데이터 타입
-  원시(primitive) : 단일 데이터
    - number, BigInt, string, boolean, null, undefined, symbol
- Number
    - 다른 언어와 달리 한 가지 숫자 타입만 있다(양수, 음수, 정수, 소수)
    - +, -, *, / (괄호가 먼저)
    - `%` 나머지 연산자 (숫자가 홀수인지 짝수인지 판단하는데 자주 쓰인다)
        
         9 % 2 // 1 (2가 몇 번 들어가는지 보면 4번, 나머지는 1)
        19 % 4 // 3
        어떤 숫자든 % 2를 해서 나머지가 1이 나오면 홀수! 짝수라면 0
        
    - `**` 지수 연산자 (후자의 숫자를 거듭제곱)
    9 ** 3 // 729 (9를 3제곱 .. 9 * 9 * 9)
    - NaN : 숫자가 아닌 값을 나타내지만 JS에서 숫자로 간주된다. 

- Boolean
    - true or false
 
- `typeof __` 뒤에 오는 것이 무슨 타입인지 알려주는 연산자
    - 자스의 특징 : 동적 언어! 할당된 값에 따라 타입이 결정된다 -> 약하게 타입이 결정!(weakly type)   
    - 예) 0/0 // NaN
    - typeof NaN // number
    - NaN을 연산하면 무조건 NaN이 나온다

<br>

- score = score + 5;
score += 5 와 같다
score *= 2 …
- score ++ // 현재값이 나온다! 그 다음부터 1씩 늘어나서 계산됨
score += 4 // 현재값에 4를 더한 값이 업데이트됨

 
<br>

- 객체(object) : 복합 데이터(연관있는 데이터를 함께 묶어서 보관할 수 있는 큰 오브젝트. 여러 데이터를 묶어서 표현하는 상태, 상태와 연관된 행동 즉 함수까지 묶어줄 수 있는 것)
    - object(array도 오브젝트), function <br>
`{key:value}` value에는 원시타입,객체타입 다 가능
```
{
id: 1234,
key:'secret-key'
}
```
콤마로 연결

## 값과 참조의 차이
- 원시 타입은 값 자체가 복사되어 메모리 셀 안에 (재할당되면 값도 바뀜) `copy by value`
- 객체는 참조값, 메모리 주소가 메모리 셀 안에 `copy by reference`

## const
- let 재할당 가능
- const 재할당 불가능 (1.상수 2.상수변수 또는 변수)
