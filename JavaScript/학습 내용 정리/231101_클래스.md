# 클래스
- 생성자 함수(붕어빵틀)를 통해 필요한 데이터를 인자로 전달하면 비슷한 구조의 객체(붕어빵)를 찍어낼 수 있었다
-> 자스가 프로토타입을 베이스로 해서 객체지향 프로그래밍을 지원하기 때문에 가능
-> 그러나 이제 현업에서 생성자 함수 잘 안쓰고, 요즘은 모던하게 클래스를 기반으로 한 객체지향 프로그래밍을 지원(ES6 도입)
- `클래스 class` : 객체를 생성할 수 있는 템플릿(청사진,틀) 이때 클래스를 통해 만들어진 객체는 인스턴스. 프로토타입보다 간편하다.
- `object-oriented programming` : 클래스를 통해 객체지향 프로그래밍을 할 수 있다. -> 절차적으로 코드를 작성하는 게 아니라 밀접하게 연관있는 것들을 객체로 구성해나가면서 객체끼리 서로 호환 가능하게 하는 것!

- 객체를 손쉽게 만들 수 있는 템플릿
```
// 1. 생성자 함수(오래된 고전적인 방법)

functuon Fruit(name, emoji) {
	this.name = name;
  	this.emoji = emoji;
  	this.display = () => {
    	console.log(`${this.name}:${this.emoji}`);
    };
}
const apple = new Fruit('apple','🍎');
const orange = new Fruit('orange','🍊');

// 클래스(New!)

class Fruit{
	// 생성자: new 키워드로 객체를 생성할 때 호출되는 함수
	constructor(name, emoji){
    this.name = name;
  	this.emoji = emoji;
    }
    display = () => {
    	console.log(`${this.name}:${this.emoji}`);
    };
}
const apple = new Fruit('apple','🍎');
const orange = new Fruit('orange','🍊');
apple.name;
apple.emoji;
apple.display;

// 이때 apple, orange이라는 객체는 Fruit 클래스의 인스턴스
```

## 재사용성을 높이는 방법
- 비슷한 부류, 비슷한 카테고리에 동일한 속성과 행동을 가지고 있는 객체를 만드는 템플릿 = 클래스
- 클래스에 정의된 프로퍼티와 메서드는 인스턴스 레벨의 프로퍼티와 메서드라고 볼 수 있다.
- 클래스를 이용해 만들어진 인스턴스는 클래스에서 만든 프로퍼티가 중복적으로 만들어진다.
- 필요한 템플릿을 지정해두고 필요한 데이터를 주입해서 동일한 것을 지속적으로 만들어낼 수 있다. -> 클래스를 통해 인스턴스를 찍어낸다. 동일한 프로퍼티와 메서드가 들어가기 때문에 인스턴스 레벨의 프로퍼타와 메서드라고 볼 수 있다.
- `객체.속성` `객체.함수` 이렇게 호출할 수 있었다
- 모든 데이터마다 동일하게 참조하는 속성이나 행동이 있어야한다면?! 클래스 레벨의 프로퍼티와 메서드를 사용하면 된다!!!!
- 클래스 안에서 static을 프로퍼티나 메서드 앞에 붙인다. 만들어진 인스턴스에 포함되지 않고 클래스에 그대로 남아있다. 클래스에 한번만 정의하고 재사용할 수 있다.
`클래스이름.함수` 이런식으로 호출해야함!

```
class Fruit {
  this.name
  this.emoji
  static make(){}
}

let apple = {
  name: 'apple',
  emoji: '🍎',
}
Fruit.make();

let orange = {
  name: 'orange',
  emoji: '🍊',
}
Fruit.make();
```
- `static 정적 프로퍼티, 메서드`
- 스태틱 안 붙이면 인스턴스 레벨! 클래스레벨 자체에서 접근 안됨
`Fruit.name``Fruit.display()` 이렇게는 접근 안됨 클래스 자체에는 데이터가 채워져있지 않으니까!
템플릿인 상태. 속성 접근해도 데이터가 없는 상태.
- `orange.name` `orange.display()` 이런 식으로 꼭 생성된 인스턴스 이름으로 접근하고 호출해야함
- display 함수는 만들어진 인스턴스와 밀접하게 연관이 있으니까 인스턴스 레벨로 두는 게 좋다!
```
class Fruit{
	constructor(name, emoji){
    this.name = name;
  	this.emoji = emoji;
    }

// 인스턴스 레벨의 메서드
	display = () => {
		console.log(`${this.name}:${this.emoji}`);
	};

// 클래스 레벨의 메서드
// 클래스 레벨의 메서드에서는 this를 참조할 수 없음. 클래스 자체로는 아무것도 채워지지 않은 템플릿 상태니까! 
	static makeRandomFruit(){
	  return new Fruit('banana','🍌');
		};
};

const banana = Fruit.makeRandomFruit();
console.log(banana);
```
- 클래스 레벨의 함수는 클래스 이름으로 접근 가능
- 인스턴스 레벨의 프로퍼티,함수는 만들어진 인스턴스를 통해 접근 가능
- static 붙이면 클래스 레벨로 만들 수 있고, 함수 앞에 붙이면 클래스 레벨의 메서드
